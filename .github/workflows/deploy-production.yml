name: Deploy to Production

on:
  workflow_dispatch:

env:
  ARM_USE_OIDC: true
  ARM_USE_CLI: false
  ENVIRONMENT: production        # used by TF / Ansible paths

permissions:
  id-token: write
  contents: read
  issues: write                  # needed by notification step

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
jobs:
# 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Manual gate (environmentâ€‘level approval) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  manual-approval:
    runs-on: ubuntu-latest
    environment:
      name: production           # GitHub Environment â†’ reviewers
    steps:
      - run: echo "Waiting for manual approvalâ€¦"

# 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Deploy infrastructure & config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    name: 'Deploy Infrastructure & Configuration'
    needs: manual-approval
    runs-on: ubuntu-latest
    environment: production

    env:
      ARM_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    outputs:
      vm_ip:   ${{ steps.tf_out.outputs.vm_ip }}
      vm_name: ${{ steps.tf_out.outputs.vm_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ env.ARM_CLIENT_ID }}
          tenant-id: ${{ env.ARM_TENANT_ID }}
          subscription-id: ${{ env.ARM_SUBSCRIPTION_ID }}

      - name: Set up tooling
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh provisioning/keys
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keygen -y -f ~/.ssh/id_rsa > provisioning/keys/id_rsa.pub

      # â”€â”€ Terraform â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Copy environment files
        run: |
          cp environments/${{ env.ENVIRONMENT }}/terraform.tfvars provisioning/
          cp environments/${{ env.ENVIRONMENT }}/backend.tf      provisioning/

      - name: Terraform init / plan / apply
        run: |
          cd provisioning
          terraform init
          terraform plan  -var-file=terraform.tfvars
          terraform apply -auto-approve -var-file=terraform.tfvars

      - name: Capture TF outputs
        id: tf_out
        run: |
          cd provisioning
          echo "vm_ip=$(terraform output -raw public_ip_address)" >> "$GITHUB_OUTPUT"
          echo "vm_name=$(terraform output -raw vm_name)"         >> "$GITHUB_OUTPUT"

      # â”€â”€ Ansible â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Build inventory
        run: |
          mkdir -p configuration-management/inventory
          cat > configuration-management/inventory/hosts.yml <<'EOF'
          all:
            children:
              azure_vms:
                hosts:
                  ${TF_VM_NAME}:
                    ansible_host: ${TF_VM_IP}
                    ansible_user: azureuser
                    ansible_ssh_private_key_file: ~/.ssh/id_rsa
                    ansible_python_interpreter: /usr/bin/python3
                vars:
                  ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
                  environment_name: '${ENVIRONMENT}'
          EOF
        env:
          TF_VM_IP:   ${{ steps.tf_out.outputs.vm_ip }}
          TF_VM_NAME: ${{ steps.tf_out.outputs.vm_name }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}

      - name: Copy group vars
        run: |
          cp environments/${{ env.ENVIRONMENT }}/ansible_vars.yml \
             configuration-management/group_vars/azure_vms.yml

      - name: Install collections
        run: |
          cd configuration-management
          ansible-galaxy collection install -r requirements.yml

      - name: Wait for SSH
        run: |
          for i in {1..10}; do
            if ssh -o BatchMode=yes -o StrictHostKeyChecking=no \
                 -o ConnectTimeout=10 azureuser@${{ steps.tf_out.outputs.vm_ip }} \
                 "echo ok" >/dev/null 2>&1; then
              echo "VM ready"; break
            fi
            echo "Waitingâ€¦ ($i/10)"; sleep 30
          done

      - name: Apply playbook
        run: |
          cd configuration-management
          ansible-playbook -i inventory/hosts.yml site.yml -v

# 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Health & security tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  health-checks:
    name: 'Health & Security Tests'
    needs: deploy
    runs-on: ubuntu-latest

    env:
      VM_IP:   ${{ needs.deploy.outputs.vm_ip }}
      VM_NAME: ${{ needs.deploy.outputs.vm_name }}
      ENVIRONMENT: production

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - run: pip install pytest testinfra pyyaml

      - name: Add SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Run test suites
        run: |
          cd tests
          pytest -v test_health.py test_security.py

# 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Notify result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  notify-deployment:
    name: 'Notify Deployment Status'
    runs-on: ubuntu-latest
    needs: [deploy, health-checks]
    if: always()
    
    steps:
    - name: Deployment notification
      uses: actions/github-script@v7
      with:
        script: |
          const deploymentStatus = '${{ needs.health-checks.result }}';
          const emoji = deploymentStatus === 'success' ? 'ðŸš€' : 'ðŸš¨';
          const status = deploymentStatus === 'success' ? 'successful' : 'failed';
          
          const message = `${emoji} Production deployment ${status}!
          
          **Environment:** Production
          **Commit:** ${context.sha.substring(0, 7)}
          **Actor:** ${context.actor}
          **Status:** ${deploymentStatus}
          
          [View deployment details](${context.payload.repository.html_url}/actions/runs/${context.runId})`;
          
          // Create a GitHub issue for deployment notification
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `${emoji} Production Deployment ${status} - ${context.sha.substring(0, 7)}`,
            body: message,
            labels: ['production', 'deployment', 'notification']
          });
          
          console.log("Production deployment notification sent");
