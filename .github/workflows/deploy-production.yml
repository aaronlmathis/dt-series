name: Deploy to Production

on:
  workflow_run:                       # ← fired by the staging pipeline
    workflows: ["Deploy to Staging"]
    types: [completed]

  workflow_dispatch:
    inputs:
      ref:
        description: 'The branch or commit SHA to deploy to production'
        required: true

env:
  ARM_USE_OIDC: true
  ARM_USE_CLI: false
  ENVIRONMENT: production        # used by TF / Ansible paths

permissions:
  id-token: write
  contents: read
  issues: write                  # needed by notification step

# ──────────────────────────────────────────────────────────────────────────────
jobs:
# 1 ────────────────── Deploy infrastructure & config ─────────────────────────
  deploy:
    name: Deploy Infrastructure & Configuration
    if: github.event_name == 'workflow_dispatch' ||
        github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    environment:
      name: production         # ← reviewers gate lives here

    env:
      ARM_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    outputs:
      vm_ip:   ${{ steps.tf_out.outputs.vm_ip }}
      vm_name: ${{ steps.tf_out.outputs.vm_name }}

    steps:
      - uses: actions/checkout@v4
        with:
          # Use the dispatch input if available, otherwise use the SHA from the completed staging run
          ref: ${{ github.event.inputs.ref || github.event.workflow_run.head_sha }}

      - name: Azure login (OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ env.ARM_CLIENT_ID }}
          tenant-id: ${{ env.ARM_TENANT_ID }}
          subscription-id: ${{ env.ARM_SUBSCRIPTION_ID }}

      - name: Set up tooling
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh provisioning/keys
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keygen -y -f ~/.ssh/id_rsa > provisioning/keys/id_rsa.pub

      # ── Terraform ──────────────────────────────────────────────────────────
      - name: Copy environment files
        run: |
          cp environments/${{ env.ENVIRONMENT }}/terraform.tfvars provisioning/
          cp environments/${{ env.ENVIRONMENT }}/backend.tf      provisioning/

      - name: Terraform init / plan / apply
        run: |
          cd provisioning
          terraform init
          terraform plan  -var-file=terraform.tfvars
          terraform apply -auto-approve -var-file=terraform.tfvars

      - name: Capture TF outputs
        id: tf_out
        run: |
          cd provisioning
          echo "vm_ip=$(terraform output -raw public_ip_address)" >> "$GITHUB_OUTPUT"
          echo "vm_name=$(terraform output -raw vm_name)"         >> "$GITHUB_OUTPUT"

      # ── Ansible ────────────────────────────────────────────────────────────
      - name: Build inventory
        run: |
          mkdir -p configuration-management/inventory
          cat > configuration-management/inventory/hosts.yml << EOF
          all:
            children:
              azure_vms:
                hosts:
                  ${TF_VM_NAME}:
                    ansible_host: ${TF_VM_IP}
                    ansible_user: azureuser
                    ansible_ssh_private_key_file: ~/.ssh/id_rsa
                    ansible_python_interpreter: /usr/bin/python3
                vars:
                  ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
                  environment_name: '${ENVIRONMENT}'
          EOF
        env:
          TF_VM_IP:   ${{ steps.tf_out.outputs.vm_ip }}
          TF_VM_NAME: ${{ steps.tf_out.outputs.vm_name }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}

      - name: Copy group vars
        run: |
          cp environments/${{ env.ENVIRONMENT }}/ansible_vars.yml \
             configuration-management/group_vars/azure_vms.yml

      - name: Install collections
        run: |
          cd configuration-management
          ansible-galaxy collection install -r requirements.yml

      - name: Wait for SSH
        run: |
          for i in {1..10}; do
            if ssh -o BatchMode=yes -o StrictHostKeyChecking=no \
                 -o ConnectTimeout=10 azureuser@${{ steps.tf_out.outputs.vm_ip }} \
                 "echo ok" >/dev/null 2>&1; then
              echo "VM ready"; break
            fi
            echo "Waiting… ($i/10)"; sleep 30
          done

      - name: Apply playbook
        run: |
          cd configuration-management
          ansible-playbook -i inventory/hosts.yml site.yml -v

# 3 ────────────────── Health & security tests ────────────────────────────────
  health-checks:
    name: 'Health & Security Tests'
    needs: deploy
    if: ${{ needs.deploy.result == 'success' }}  
    runs-on: ubuntu-latest

    env:
      VM_IP:   ${{ needs.deploy.outputs.vm_ip }}
      VM_NAME: ${{ needs.deploy.outputs.vm_name }}
      ENVIRONMENT: production

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - run: pip install pytest testinfra pyyaml

      - name: Add SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Run test suites
        run: |
          cd tests
          pytest -v test_health.py test_security.py

# 4 ────────────────── Notify result ──────────────────────────────────────────

  notify-deployment:
    name: 'Notify Deployment Status'
    runs-on: ubuntu-latest
    needs: [deploy, health-checks]
    if: ${{ always() && needs.deploy.result != 'skipped' }} 
    
    steps:
    - name: Deployment notification
      uses: actions/github-script@v7
      with:
        script: |
          const deploymentStatus = '${{ needs.health-checks.result }}';
          const emoji = deploymentStatus === 'success' ? '[SUCCESS]' : '[FAILURE]';
          const status = deploymentStatus === 'success' ? 'successful' : 'failed';
          
          const message = `${emoji} Production deployment ${status}!
          
          **Environment:** Production
          **Commit:** ${context.sha.substring(0, 7)}
          **Actor:** ${context.actor}
          **Status:** ${deploymentStatus}
          
          [View deployment details](${context.payload.repository.html_url}/actions/runs/${context.runId})`;
          
          // Create a GitHub issue for deployment notification
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `${emoji} Production Deployment ${status} - ${context.sha.substring(0, 7)}`,
            body: message,
            labels: ['production', 'deployment', 'notification']
          });
          
          console.log("Production deployment notification sent");
